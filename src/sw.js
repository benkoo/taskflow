// Import Workbox modules
importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.5.4/workbox-sw.js');

// Set workbox config
workbox.setConfig({
  debug: process.env.NODE_ENV !== 'production',
});

const { precacheAndRoute, createHandlerBoundToURL } = workbox.precaching;
const { registerRoute, NavigationRoute } = workbox.routing;
const { CacheFirst, StaleWhileRevalidate } = workbox.strategies;
const { ExpirationPlugin } = workbox.expiration;
const { clientsClaim } = workbox.core;
const { setCacheNameDetails } = workbox.core;

// Set cache name prefix
setCacheNameDetails({
  prefix: 'taskflow',
  suffix: 'v1',
  precache: 'precache',
  runtime: 'runtime',
  googleAnalytics: 'ga',
});

// Enable clients claim to ensure all clients are controlled by the service worker
clientsClaim();

// Precache and route the application shell
const manifest = self.__WB_MANIFEST || [];
const precacheManifest = manifest.map(entry => {
  // Ensure URLs are properly formatted
  if (typeof entry === 'string') {
    return { url: entry, revision: null };
  }
  return entry;
});

// Add fallback URLs to ensure the app works offline
precacheManifest.push(
  { url: '/', revision: null },
  { url: '/index.html', revision: null },
  { url: '/?source=pwa', revision: null }
);

// Log the manifest for debugging
console.log('Service Worker: Precaching manifest:', precacheManifest);

// Precache all the assets generated by your build process with error handling
try {
  precacheAndRoute(precacheManifest, {
    // Ignore URL parameters
    ignoreURLParametersMatching: [/^utm_/, /^fbclid$/],
    // Don't cache bust URL's that are already revisioned
    cleanURLs: true,
  });
} catch (error) {
  console.error('Service Worker: Error during precaching:', error);
}

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with the index.html shell.
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    }

    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith('/_')) {
      return false;
    }

    // If this looks like a URL for a resource, because it contains a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL('/index.html')
);

// Cache Google Fonts with a cache-first strategy
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com' ||
             url.origin === 'https://fonts.gstatic.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Cache images with a cache-first strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Cache CSS and JavaScript with a stale-while-revalidate strategy
registerRoute(
  ({ request }) => 
    request.destination === 'style' || 
    request.destination === 'script' ||
    request.destination === 'worker',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Cache API responses with network-first strategy
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new StaleWhileRevalidate({
    cacheName: 'api-responses',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 5, // 5 minutes
      }),
    ],
  })
);

// Handle offline fallback
const FALLBACK_HTML_URL = '/offline.html';
const FALLBACK_IMAGE_URL = '/images/offline.svg';

// This assumes you have an offline.html in your public folder
workbox.precaching.precacheAndRoute([
  { url: FALLBACK_HTML_URL, revision: null },
  { url: FALLBACK_IMAGE_URL, revision: null },
]);

// Return a fallback response for failed requests
const handlerCatch = () => {
  return caches.match(FALLBACK_HTML_URL, { ignoreSearch: true });
};

// Set a catch handler to show the offline page for any unhandled requests
workbox.routing.setCatchHandler(async ({event}) => {
  // Return the offline page if this is a navigation request
  if (event.request.mode === 'navigate') {
    return caches.match(FALLBACK_HTML_URL);
  }
  // Return the offline image for failed image requests
  if (event.request.destination === 'image') {
    return caches.match(FALLBACK_IMAGE_URL);
  }
  return Response.error();
});

// Clean up old caches when a new service worker is activated
self.addEventListener('activate', (event) => {
  const cacheAllowlist = ['taskflow-precache-v1', 'taskflow-runtime-v1'];
  
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (!cacheAllowlist.includes(cacheName)) {
            console.log('Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
  
  // Take control of all clients immediately
  event.waitUntil(clients.claim());
});

// Handle push events
self.addEventListener('push', (event) => {
  if (!(self.Notification && self.Notification.permission === 'granted')) {
    return;
  }

  const data = event.data?.json() || { title: 'New notification', body: 'You have a new notification' };
  
  const title = data.title || 'TaskFlow';
  const options = {
    body: data.body,
    icon: '/icons/icon-192x192.png',
    badge: '/icons/icon-192x192.png',
    data: data.data || {},
    ...data.options,
  };

  event.waitUntil(self.registration.showNotification(title, options));
});

// Handle notification click events
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  // Handle the notification click
  event.waitUntil(
    clients.matchAll({ type: 'window' }).then((clientList) => {
      // Check if there's already a window/tab open with the app
      for (const client of clientList) {
        if (client.url === '/' && 'focus' in client) {
          return client.focus();
        }
      }
      
      // If no client is open, open a new one
      if (clients.openWindow) {
        return clients.openWindow('/');
      }
    })
  );
});

// Handle push subscription changes
self.addEventListener('pushsubscriptionchange', (event) => {
  event.waitUntil(
    Promise.all([
      self.registration.pushManager.getSubscription(),
      self.registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: process.env.PUBLIC_VAPID_PUBLIC_KEY,
      }),
    ]).then(([subscription]) => {
      // Send the new subscription to your server
      if (subscription) {
        return fetch('/api/update-subscription', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            old_subscription: subscription,
            new_subscription: subscription,
          }),
        });
      }
    })
  );
});

// Handle background sync
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-tasks') {
    event.waitUntil(syncTasks());
  }
});

// Example background sync function
async function syncTasks() {
  // Implement your background sync logic here
  // This will run when the device comes back online
  console.log('Syncing tasks in the background...');
  
  // Example: Get tasks from IndexedDB and sync with the server
  const tasks = await getTasksFromIndexedDB();
  
  for (const task of tasks) {
    if (task.status === 'pending_sync') {
      await syncTaskWithServer(task);
    }
  }
}

// Helper functions
async function getTasksFromIndexedDB() {
  // Implement IndexedDB access
  return [];
}

async function syncTaskWithServer(task) {
  // Implement server sync logic
  return Promise.resolve();
}
