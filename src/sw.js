// Import Workbox modules
importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.5.4/workbox-sw.js');

// Set workbox config
workbox.setConfig({
  debug: process.env.NODE_ENV !== 'production',
});

const { precacheAndRoute } = workbox.precaching;
const { registerRoute } = workbox.routing;
const { CacheFirst, StaleWhileRevalidate } = workbox.strategies;
const { ExpirationPlugin } = workbox.expiration;
const { clientsClaim } = workbox.core;

// Enable clients claim to ensure all clients are controlled by the service worker
clientsClaim();

// Precache all the assets generated by your build process.
precacheAndRoute(self.__WB_MANIFEST);

// Cache Google Fonts with a cache-first strategy
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com' ||
             url.origin === 'https://fonts.gstatic.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Cache images with a cache-first strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Handle push events
self.addEventListener('push', (event) => {
  if (!(self.Notification && self.Notification.permission === 'granted')) {
    return;
  }

  const data = event.data?.json() || { title: 'New notification', body: 'You have a new notification' };
  
  const title = data.title || 'TaskFlow';
  const options = {
    body: data.body,
    icon: '/icons/icon-192x192.png',
    badge: '/icons/icon-192x192.png',
    data: data.data || {},
    ...data.options,
  };

  event.waitUntil(self.registration.showNotification(title, options));
});

// Handle notification click events
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  // Handle the notification click
  event.waitUntil(
    clients.matchAll({ type: 'window' }).then((clientList) => {
      // Check if there's already a window/tab open with the app
      for (const client of clientList) {
        if (client.url === '/' && 'focus' in client) {
          return client.focus();
        }
      }
      
      // If no client is open, open a new one
      if (clients.openWindow) {
        return clients.openWindow('/');
      }
    })
  );
});

// Handle push subscription changes
self.addEventListener('pushsubscriptionchange', (event) => {
  event.waitUntil(
    Promise.all([
      self.registration.pushManager.getSubscription(),
      self.registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: process.env.PUBLIC_VAPID_PUBLIC_KEY,
      }),
    ]).then(([subscription]) => {
      // Send the new subscription to your server
      if (subscription) {
        return fetch('/api/update-subscription', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            old_subscription: subscription,
            new_subscription: subscription,
          }),
        });
      }
    })
  );
});

// Handle background sync
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-tasks') {
    event.waitUntil(syncTasks());
  }
});

// Example background sync function
async function syncTasks() {
  // Implement your background sync logic here
  // This will run when the device comes back online
  console.log('Syncing tasks in the background...');
  
  // Example: Get tasks from IndexedDB and sync with the server
  const tasks = await getTasksFromIndexedDB();
  
  for (const task of tasks) {
    if (task.status === 'pending_sync') {
      await syncTaskWithServer(task);
    }
  }
}

// Helper functions
async function getTasksFromIndexedDB() {
  // Implement IndexedDB access
  return [];
}

async function syncTaskWithServer(task) {
  // Implement server sync logic
  return Promise.resolve();
}
